import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c,b as d,o as n}from"./app-D2fNj2_6.js";const t={};function a(i,e){return n(),c("div",null,e[0]||(e[0]=[d('<div class="hint-container warning"><p class="hint-container-title">注意</p><p>编写此文档时，<code>GoneBot</code> 版本为 <code>v1.1.4</code></p></div><p>在 <code>GoneBot</code> 中，适配器的生命周期非常简单，开始，和结束。也就是适配器的启动和销毁。</p><p>在定义上，适配器需要实现 <code>Start</code> 方法和 <code>Finalize</code> 方法，这两个方法均不需要任何参数，其中 <code>Start</code> 方法会通过 <code>goroutine</code> 启动，适配器应当在 <code>Start</code> 方法中启动自己的业务逻辑，<code>Finalize</code> 方法会在 <code>GoneBot</code> 关闭时调用，适配器应当在此方法中释放资源，防止泄漏。</p><h2 id="开始" tabindex="-1"><a class="header-anchor" href="#开始"><span>开始</span></a></h2><p>在 <code>Start</code> 方法启动之后，适配器有一些不得不做的工作，以方便 <code>GoneBot</code> 能够正常工作：</p><ul><li><h3 id="_1-启动消息收取" tabindex="-1"><a class="header-anchor" href="#_1-启动消息收取"><span>1. 启动消息收取</span></a></h3></li></ul><p>  适配器应当以自己的方式收取来自聊天平台的消息，并将消息转换为 <code>GoneBot</code> 规定的 <code>Message</code> 类型，并使用 <code>ReceiveChannel.Push(msg, true)</code> 将消息塞入适配器的收取消息队列，<code>GoneBot</code> 会从此队列中取出消息，并将消息传递给插件。</p><ul><li><h3 id="_2-启动消息发送" tabindex="-1"><a class="header-anchor" href="#_2-启动消息发送"><span>2. 启动消息发送</span></a></h3></li></ul><p>  在经过插件的处理之后，插件的回复会被塞入适配器的发送消息队列 <code>SendChannel</code>，适配器需要将这些回复以自己的方式发送到聊天平台。</p><ul><li><h3 id="_3-启动行为监听" tabindex="-1"><a class="header-anchor" href="#_3-启动行为监听"><span>3. 启动行为监听</span></a></h3></li></ul><p>  如果聊天平台实现了一些自定义行为（如 QQ 的戳一戳等），插件可能会产生一些行为调用，<code>GoneBot</code> 会将这些调用塞入适配器的 <code>ActionChannel</code>，适配器需要处理这些行为，并将处理结果塞入传入的 <code>ActionCall</code> 所指定的 <code>ResultChannel</code>。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>无论调用结果如何，你都需要塞<strong>至少一个</strong>结果进入 <code>ResultChannel</code>，否则调用该行为的插件会原地卡死！</p><p>我警告你！🫵🫵🫵</p></div><h2 id="结束" tabindex="-1"><a class="header-anchor" href="#结束"><span>结束</span></a></h2><p>在 <code>GoneBot</code> 关闭时，会依次调用所有适配器的 <code>Finalize</code> 方法，适配器应当在此方法中释放所有资源，防止泄漏。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>但这并不意味着你可以随意阻塞线程！否则会导致 <code>GoneBot</code> 不能正常关闭！</p></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>直到 <code>v1.1.4</code> 版本，<code>GoneBot</code> 还无法在用户使用 <code>Ctrl+C</code> 时正常退出，在之后的版本中，<code>GoneBot</code> 将会尝试修复这个问题</p></div>',16)]))}const s=o(t,[["render",a],["__file","lifecycle.html.vue"]]),p=JSON.parse('{"path":"/zh/guide/adapter/lifecycle.html","title":"生命周期","lang":"zh-CN","frontmatter":{"title":"生命周期","icon":"heart-pulse","order":2,"category":["文档"],"tag":["适配器","生命周期"],"author":"Kingcq"},"headers":[{"level":2,"title":"开始","slug":"开始","link":"#开始","children":[]},{"level":2,"title":"结束","slug":"结束","link":"#结束","children":[]}],"git":{"createdTime":1733397969000,"updatedTime":1733397969000,"contributors":[{"name":"Kingcq","email":"404291187@qq.com","commits":1}]},"readingTime":{"minutes":1.93,"words":580},"filePathRelative":"zh/guide/adapter/lifecycle.md","localizedDate":"2024年12月5日","excerpt":"<div class=\\"hint-container warning\\">\\n<p class=\\"hint-container-title\\">注意</p>\\n<p>编写此文档时，<code>GoneBot</code> 版本为 <code>v1.1.4</code></p>\\n</div>\\n<p>在 <code>GoneBot</code> 中，适配器的生命周期非常简单，开始，和结束。也就是适配器的启动和销毁。</p>\\n<p>在定义上，适配器需要实现 <code>Start</code> 方法和 <code>Finalize</code> 方法，这两个方法均不需要任何参数，其中 <code>Start</code> 方法会通过 <code>goroutine</code> 启动，适配器应当在 <code>Start</code> 方法中启动自己的业务逻辑，<code>Finalize</code> 方法会在 <code>GoneBot</code> 关闭时调用，适配器应当在此方法中释放资源，防止泄漏。</p>"}');export{s as comp,p as data};
